name: Build and Release
run-name: Build / create_release ${{ github.event.inputs.create_release }}

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to build for'
        required: true
        default: 'linux,windows,macos'
        type: choice
        options:
          - 'linux,windows,macos'
          - 'linux'
          - 'windows'
          - 'macos'
          - 'linux,windows'
          - 'linux,macos'
          - 'windows,macos'
      create_release:
        description: 'Create a GitHub release (only for manual builds)'
        required: false
        default: false
        type: boolean

jobs:
  manage-version:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'
    outputs:
      version: ${{ steps.final_version.outputs.version }}
      tag_name: ${{ steps.final_version.outputs.tag_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Read current version
        id: read_version
        shell: bash
        run: |
          VERSION=$(python -c "exec(open('src/_version.py').read()); print(__version__)")
          echo "current_version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Current version: $VERSION"

      - name: Check if tag exists and bump version if needed
        id: bump_version
        shell: bash
        run: |
          CURRENT_VERSION="${{ steps.read_version.outputs.current_version }}"
          TAG_NAME="v$CURRENT_VERSION"
          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "Tag $TAG_NAME already exists, bumping version..."
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            NEW_TAG_NAME="v$NEW_VERSION"
            {
              echo "new_version=$NEW_VERSION"
              echo "needs_bump=true"
              echo "tag_name=$NEW_TAG_NAME"
            } >> "$GITHUB_OUTPUT"
          else
            {
              echo "new_version=$CURRENT_VERSION"
              echo "needs_bump=false"
              echo "tag_name=$TAG_NAME"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Update version file if needed
        if: steps.bump_version.outputs.needs_bump == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.bump_version.outputs.new_version }}"
          sed -i "s/__version__ = .*/__version__ = \"$NEW_VERSION\"/" src/_version.py
          cat src/_version.py

      - name: Commit version update
        if: steps.bump_version.outputs.needs_bump == 'true'
        shell: bash
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add src/_version.py
          git commit -m "Bump version to ${{ steps.bump_version.outputs.new_version }}"
          git push

      - name: Create tag
        id: create_tag
        shell: bash
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          VERSION="${{ steps.bump_version.outputs.new_version }}"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "$TAG_NAME" -m "Release $VERSION"
          git push origin "$TAG_NAME"

      - name: Set final outputs
        id: final_version
        shell: bash
        run: |
          echo "version=${{ steps.bump_version.outputs.new_version }}" >> "$GITHUB_OUTPUT"
          echo "tag_name=${{ steps.bump_version.outputs.tag_name }}" >> "$GITHUB_OUTPUT"

  create-release:
    runs-on: ubuntu-latest
    needs: [manage-version]
    if: always() && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'))
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version
        id: get_version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="${{ needs.manage-version.outputs.version }}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Found version: $VERSION"

      - name: Compute tag
        id: compute_tag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=${{ needs.manage-version.outputs.tag_name }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.compute_tag.outputs.tag }}
          release_name: ${{ github.event.repository.name }}-${{ steps.get_version.outputs.version }}
          draft: false
          prerelease: ${{ github.event_name == 'workflow_dispatch' }}

  build:
    needs: [create-release]
    if: always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            arch: x64
            binary_extension: ""
            archive_extension: ".tar.gz"
          - os: windows-latest
            platform: windows
            arch: x64
            binary_extension: ".exe"
            archive_extension: ".zip"
          - os: macos-latest
            platform: macos
            arch: arm64
            binary_extension: ""
            archive_extension: ".tar.gz"
    runs-on: ${{ matrix.os }}
    steps:
      - name: Check if platform should be built
        id: should_build
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "build=true" >> "$GITHUB_OUTPUT"
            echo "Building all platforms for release"
          elif [[ "${{ github.event.inputs.platforms }}" == *"${{ matrix.platform }}"* ]]; then
            echo "build=true" >> "$GITHUB_OUTPUT"
            echo "Building ${{ matrix.platform }} (selected in manual build)"
          else
            echo "build=false" >> "$GITHUB_OUTPUT"
            echo "Skipping ${{ matrix.platform }} (not selected in manual build)"
          fi

      - name: Checkout code
        if: steps.should_build.outputs.build == 'true'
        uses: actions/checkout@v4

      - name: Set up Python
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install system dependencies (Ubuntu)
        if: steps.should_build.outputs.build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            python3.12-tk \
            libgl1-mesa-dev \
            libglib2.0-0 \
            libgomp1 \
            xvfb \
            upx-ucl \
            binutils

      - name: Install system dependencies (macOS)
        if: steps.should_build.outputs.build == 'true' && matrix.platform == 'macos'
        shell: bash
        run: |
          brew install python@3.12 tcl-tk || true
          echo 'export PATH="/usr/local/opt/tcl-tk/bin:$PATH"' >> "$GITHUB_ENV"
          echo 'export PKG_CONFIG_PATH="/usr/local/opt/tcl-tk/lib/pkgconfig"' >> "$GITHUB_ENV"
          brew install upx || true

      - name: Install system dependencies (Windows)
        if: steps.should_build.outputs.build == 'true' && matrix.os == 'windows-latest'
        shell: bash
        run: |
          choco install upx -y || echo "UPX installation failed, continuing without it"

      - name: Create and configure virtual environment
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          python -m venv venv
          if [ -d "venv/Scripts" ]; then
            # Windows
            echo "VIRTUAL_ENV=${{ github.workspace }}/venv" >> "$GITHUB_ENV"
            echo "${{ github.workspace }}/venv/Scripts" >> "$GITHUB_PATH"
          else
            # Linux / macOS
            echo "VIRTUAL_ENV=${{ github.workspace }}/venv" >> "$GITHUB_ENV"
            echo "${{ github.workspace }}/venv/bin" >> "$GITHUB_PATH"
          fi

      - name: Upgrade pip and install build tools
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install wheel setuptools

      - name: Install PyInstaller
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          pip install pyinstaller==6.3.0

      - name: Install all requirements from requirements.txt
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          pip install -r requirements.txt || echo "Some dependencies may not be available, continuing with stub implementation if needed"


      - name: Build executable with PyInstaller
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            export DISPLAY=:99
            Xvfb :99 -screen 0 1024x768x24 >/dev/null 2>&1 &
            sleep 3
          fi
          if [ "${{ matrix.os }}" = "macos-latest" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            export ARCHFLAGS="-arch arm64"
          fi
          pyinstaller babeldoc_gui.spec

      - name: Verify build
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          ls -la dist/
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            file dist/babeldoc_gui.exe || true
          else
            file dist/babeldoc_gui || true
          fi

      - name: Test executable (basic smoke test)
        if: steps.should_build.outputs.build == 'true'
        continue-on-error: true
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            export DISPLAY=:99
            timeout 10 ./dist/babeldoc_gui --help || echo "GUI test skipped (expected for headless environment)"
          elif [ "${{ matrix.os }}" = "macos-latest" ]; then
            timeout 10 ./dist/babeldoc_gui --help || echo "GUI test skipped (expected for headless macOS environment)"
          else
            timeout 10 ./dist/babeldoc_gui.exe --help || echo "GUI test skipped (expected for headless environment)"
          fi

      - name: Create archive name
        if: steps.should_build.outputs.build == 'true'
        id: archive_name
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            ARCHIVE_NAME="babeldoc_gui-${{ matrix.platform }}-${{ matrix.arch }}"
          else
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            ARCHIVE_NAME="babeldoc_gui-${{ matrix.platform }}-${{ matrix.arch }}-${TIMESTAMP}"
          fi
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> "$GITHUB_OUTPUT"
          echo "Archive name: $ARCHIVE_NAME"

      - name: Create archive (Unix)
        if: steps.should_build.outputs.build == 'true' && matrix.os != 'windows-latest'
        shell: bash
        working-directory: dist
        run: |
          tar -czf "../${{ steps.archive_name.outputs.ARCHIVE_NAME }}${{ matrix.archive_extension }}" "babeldoc_gui${{ matrix.binary_extension }}"

      - name: Create archive (Windows)
        if: steps.should_build.outputs.build == 'true' && matrix.os == 'windows-latest'
        shell: bash
        run: |
          cd dist
          7z a "../${{ steps.archive_name.outputs.ARCHIVE_NAME }}${{ matrix.archive_extension }}" "babeldoc_gui${{ matrix.binary_extension }}"

      - name: Upload Release Asset
        if: steps.should_build.outputs.build == 'true' && needs.create-release.result == 'success'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ steps.archive_name.outputs.ARCHIVE_NAME }}${{ matrix.archive_extension }}
          asset_name: ${{ steps.archive_name.outputs.ARCHIVE_NAME }}${{ matrix.archive_extension }}
          asset_content_type: application/octet-stream

      - name: Upload build artifacts
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.archive_name.outputs.ARCHIVE_NAME }}
          path: ./${{ steps.archive_name.outputs.ARCHIVE_NAME }}${{ matrix.archive_extension }}
          retention-days: 30
